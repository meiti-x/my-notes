"use strict";(self.webpackChunkmy_notes=self.webpackChunkmy_notes||[]).push([[9638],{3931:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"\u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631/\u062c\u0627\u0648\u0627\u0627\u0633\u06a9\u0631\u06cc\u067e\u062a/Garbage_Collection","title":"GC in Js","description":"In software engineering, garbage refers to variables and references that are no longer in use. These leftover values still take up memory and should be cleaned up, either manually (in low-level languages like C or C++) or automatically (in higher-level languages like JavaScript).","source":"@site/docs/\u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631/\u062c\u0627\u0648\u0627\u0627\u0633\u06a9\u0631\u06cc\u067e\u062a/Garbage_Collection.md","sourceDirName":"\u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631/\u062c\u0627\u0648\u0627\u0627\u0633\u06a9\u0631\u06cc\u067e\u062a","slug":"/\u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631/\u062c\u0627\u0648\u0627\u0627\u0633\u06a9\u0631\u06cc\u067e\u062a/Garbage_Collection","permalink":"/my-notes/docs/\u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631/\u062c\u0627\u0648\u0627\u0627\u0633\u06a9\u0631\u06cc\u067e\u062a/Garbage_Collection","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"js","permalink":"/my-notes/docs/tags/js"}],"version":"current","lastUpdatedAt":1750927162000,"frontMatter":{"tags":["js"],"title":"GC in Js"},"sidebar":"tutorialSidebar","previous":{"title":"Browser Optimization","permalink":"/my-notes/docs/\u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631/\u062c\u0627\u0648\u0627\u0627\u0633\u06a9\u0631\u06cc\u067e\u062a/Browser_Optimization"},"next":{"title":"Parsing","permalink":"/my-notes/docs/\u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631/\u062c\u0627\u0648\u0627\u0627\u0633\u06a9\u0631\u06cc\u067e\u062a/Parsing"}}');var t=o(4848),r=o(8453);const a={tags:["js"],title:"GC in Js"},i=void 0,l={},c=[{value:"How Garbage Collection Works in JS",id:"how-garbage-collection-works-in-js",level:2},{value:"Conculosion:  Writing GC-Friendly JavaScript",id:"conculosion--writing-gc-friendly-javascript",level:2},{value:"Monitoring Tools",id:"monitoring-tools",level:3}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)("span",{dir:"ltr",children:[(0,t.jsxs)(n.p,{children:["In software engineering, ",(0,t.jsx)(n.em,{children:"garbage"})," refers to variables and references that are no longer in use. These leftover values still take up memory and should be cleaned up, either manually (in low-level languages like C or C++) or automatically (in higher-level languages like JavaScript)."]}),(0,t.jsxs)(n.p,{children:["JavaScript handles memory automatically through a built-in process called ",(0,t.jsx)(n.strong,{children:"garbage collection"}),". As a developer, you don\u2019t need to explicitly free memory, but understanding how the garbage collector works can help you avoid memory leaks and write more efficient, performant code."]}),(0,t.jsx)(n.p,{children:"JavaScript memory is divided into two main regions: the stack and the heap. The stack is where primitive values like numbers, booleans, null, undefined, and symbols are stored. It\u2019s fast and automatically cleaned up when a function finishes executing. The heap, on the other hand, is used for storing objects and functions. This is where garbage collection takes place, because heap memory is dynamic and sticks around until the runtime determines it\u2019s no longer needed."}),(0,t.jsx)(n.h2,{id:"how-garbage-collection-works-in-js",children:"How Garbage Collection Works in JS"}),(0,t.jsxs)(n.p,{children:["V8  use a strategy called ",(0,t.jsx)(n.strong,{children:"generational garbage collection"}),". This approach is based on the observation that most objects die young \u2014 meaning they are created and discarded quickly. So, the heap is split into two regions: the young generation and the old generation."]}),(0,t.jsx)(n.p,{children:"The young generation, often called the nursery, is where newly created objects live. This area is scanned frequently and collected using a copying algorithm. When collection happens, only the live objects are copied to a new space, and the rest are discarded. This makes collection fast and naturally compacts memory, as live objects are packed together."}),(0,t.jsxs)(n.p,{children:["If an object survives several rounds of garbage collection in the young generation, it gets promoted to the old generation. This region is scanned less frequently and cleaned up using a ",(0,t.jsx)(n.strong,{children:"mark-sweep-compact"})," algorithm. First, the runtime marks all reachable objects. Then, it sweeps away the unreachable ones. If there\u2019s significant memory fragmentation, it may also compact the memory by moving live objects around to make allocation more efficient."]}),(0,t.jsxs)(n.p,{children:["While some phases of garbage collection are non-blocking \u2014 such as marking, which can happen asynchronously \u2014 others are not. ",(0,t.jsx)(n.strong,{children:"Sweeping"})," and ",(0,t.jsx)(n.strong,{children:"compacting"})," are ",(0,t.jsx)(n.strong,{children:"Stop-The-World (STW)"})," operations. That means JavaScript execution is paused entirely while the garbage collector frees memory or rearranges the heap. This can lead to small but noticeable delays, especially in memory-heavy applications or those with poor memory hygiene."]}),(0,t.jsx)(n.p,{children:"To reduce the chances of hitting performance problems, it\u2019s important to write code that doesn\u2019t hold onto memory unnecessarily."}),(0,t.jsx)(n.h2,{id:"conculosion--writing-gc-friendly-javascript",children:"Conculosion:  Writing GC-Friendly JavaScript"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Avoid global variables"}),": Global state lives throughout the app\u2019s lifetime and can\u2019t be garbage collected easily."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Be cautious with closures"}),": If a closure holds references to large or stale data, it can prevent that memory from being released."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Clean up timers"}),": Always call ",(0,t.jsx)(n.code,{children:"clearTimeout"})," or ",(0,t.jsx)(n.code,{children:"clearInterval"})," when they're no longer needed."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Don\u2019t overuse React Context"}),": Passing large objects through context can cause them to linger in memory longer than necessary."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Unsubscribe from subscriptions and event listeners"}),": If your component sets up a listener or subscribes to an external API (like ",(0,t.jsx)(n.code,{children:"WebSocket"}),", ",(0,t.jsx)(n.code,{children:"ResizeObserver"}),", or a store), always clean it up during unmount."]}),"\n"]}),"\n"]}),(0,t.jsx)(n.h3,{id:"monitoring-tools",children:"Monitoring Tools"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DevTools Memory tab"}),": Take heap snapshots, find detached nodes, and inspect retained memory."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DevTools Performance tab"}),": Record CPU + memory usage and look for GC spikes or long STW pauses."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"console.memory"})}),": Check memory usage in Chrome at runtime. Not precise, but useful for tracking trends."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>i});var s=o(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);