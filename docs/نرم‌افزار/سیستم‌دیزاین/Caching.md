---
tags:
  - system_design
---

کشینگ یه تکنیکه که از محاسبات قبلی استفاده کنیم و لازم نباشه دوباره سیستم رو درگیر کنیم

چند تا تکنیک
### **1. Lazy Evaluation

**چی هست؟**  
Lazy Evaluation یعنی محاسبات فقط زمانی انجام می‌شن که واقعاً نیاز به نتیجه‌شون باشه.  
به‌جای اینکه از قبل همه چیز رو حساب کنیم (حتی اگه شاید هیچ‌وقت استفاده نشن)، صبر می‌کنیم تا موقع نیاز.

**مثال واقعی:**  
فرض کن یه تابع داریم که یه آرایه بزرگ رو فیلتر می‌کنه، ولی در نهایت فقط به اولین نتیجه نیاز داریم. توی lazy evaluation، فقط تا همون اولین نتیجه پردازش می‌شه، بقیه نادیده گرفته می‌شن.
    
---

### **2. Debounce / Throttle (کنترل فراخوانی توابع)**

این‌ها تکنیک‌هایی هستن برای جلوگیری از اجرای بیش از حد تابع‌ها، مخصوصاً در رویدادهایی که خیلی سریع و زیاد تکرار می‌شن (مثل scroll، resize، تایپ کردن).

#### ✅ Debounce (دِبانس):

**چی هست؟**  
وقتی تابعی صدا زده می‌شه، صبر می‌کنه ببینه آیا کاربر هنوز داره همون کار رو ادامه می‌ده یا نه. اگه یه وقفه افتاد، بعد اجرا می‌شه.

**مثال:** کاربر داره توی input تایپ می‌کنه. فقط وقتی ۵۰۰ میلی‌ثانیه تایپ نکنه، تابع اجرا بشه (مثلاً برای سرچ کردن).

**هدف:** کاهش تعداد اجرا — اجرا فقط وقتی کاربر "متوقف" بشه.

---

#### ✅ Throttle (تِراتل):

**چی هست؟**  
تابع فقط در بازه‌های زمانی مشخصی اجازه داره اجرا بشه، حتی اگه بارها صدا زده بشه.

**مثال:** کاربر داره اسکرول می‌کنه. تابع فقط هر ۱۰۰ میلی‌ثانیه یه‌بار اجرا می‌شه.

**هدف:** کنترل نرخ اجرا — اجرا در فواصل منظم، نه با هر بار تحریک.

---

### **3. Memoization with LRU (Least Recently Used)**

**چی هست؟**  
یه روش پیشرفته‌تر از memoization ساده. فرض کن یه تابع بارها با ورودی‌های مختلف صدا زده می‌شه. اگه بخوای همه نتایج رو تو کش نگه داری، ممکنه حافظه‌ات پر شه.

**LRU می‌گه:**

> «اگه ظرفیت کش پر شد، اون نتیجه‌ای که "قدیمی‌ترین بار" استفاده شده رو بنداز دور.»



## استراتژی
### 1. **Cache First**

اول کش چک می‌کنیم، اگه داده تو کش موجود بود، همون رو برمی‌گردونیم. اگه نبود، از شبکه/سرور می‌گیریم و کش رو به‌روز می‌کنیم.  
✅ سریع و کم‌هزینه  
❌ ممکنه داده قدیمی باشه

### 2. **Network First**

اول از شبکه درخواست می‌زنیم. اگه موفق بود، کش رو هم آپدیت می‌کنیم. اگه شبکه در دسترس نبود، از کش استفاده می‌کنیم.  
✅ اطلاعات همیشه تازه  
❌ در نبود اینترنت یا تأخیر شبکه ممکنه کند باشه

### 3. **Cache Only**

فقط از کش استفاده می‌کنیم. اگه داده‌ای تو کش نبود، هیچ داده‌ای برنمی‌گرده.  
✅ فوق‌العاده سریع  
❌ وابسته به کش

### 4. **Network Only**

فقط از شبکه می‌گیریم و کاری به کش نداریم.  
✅ همیشه جدیدترین اطلاعات  
❌ همیشه به شبکه وابسته

### 5. **Stale-While-Revalidate**

داده‌ی کش‌شده سریع برگردونده می‌شه، ولی هم‌زمان یه درخواست جدید برای گرفتن نسخه‌ی تازه داده فرستاده می‌شه تا کش رو آپدیت کنه.  
✅ سریع + به‌روز  
❌ کمی پیچیده‌تر برای پیاده‌سازی