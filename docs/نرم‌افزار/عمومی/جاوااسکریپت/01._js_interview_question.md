---
tags:
  - js
title: js interview question
---

###  Ù‡ÙˆÛŒØ³Øª Ú†ÛŒÙ‡ ØŸ
Ø¨Ù‡ Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø§Ù„Ø§ Ø¨Ø±Ø¯Ù† Ù…Ù‚Ø§Ø¯ÛŒØ± var, function Ø¨Ù‡ Ø§Ø¨ØªØ¯Ø§ÛŒ Ù‡Ù…ÙˆÙ† Ø§Ø³Ú©ÙˆÙ¾ Ù…ÛŒÚ¯Ù† Ù‡ÙˆÛŒØ³Øª. 
Ùˆ let const Ù‡ÙˆÛŒØ³Øª Ù†Ù…ÛŒØ´Ù†


### ÙØ±Ù‚ let, var const Ú†ÛŒÙ‡ØŸ

Ù…Ù†Ø¸ÙˆØ± Ø§Ø² redeclared Ø³Ø§Ø®Øª Ù…Ø¬Ø¯Ø¯ ÛŒÚ© Ù…ØªØºÛŒØ± Ø¨Ø§ Ù‡Ù…ÙˆÙ† Ù†Ø§Ù… Ù‡ØªØ³Ø´

~~~js
var foo = 1;
var foo = 2;
console.log(foo); // 2

let baz = 3;
let baz = 4; // Uncaught SyntaxError: Identifier 'baz' has already been declared
~~~

Ø¬Ø¯ÙˆÙ„ Ù…Ù‚Ø§ÛŒØ³Ù‡

|Behavior|`var`|`let`|`const`|
|---|---|---|---|
|Scope|Function or Global|Block|Block|
|Initialization|Optional|Optional|Required|
|Redeclaration|Yes|No|No|
|Reassignment|Yes|Yes|No|
|Accessing before declaration|`undefined`|`ReferenceError`|`ReferenceError`|

https://www.greatfrontend.com/questions/quiz/what-are-the-differences-between-variables-created-using-let-var-or-const?language=js&tab=quiz
### ÙØ±Ù‚ == Ùˆ === Ú†ÛŒÙ‡ØŸ
ØªÙˆÛŒ Ø¯ÙˆØªØ§ Ù…Ø³Ø§ÙˆÛŒ Ø³Ø¹ÛŒ Ù…ÛŒÚ©Ù†Ù‡ ØªØ§ÛŒÙ¾ Ù‡Ø§ Ø±Ùˆ coerse Ú©Ù†Ù‡ ÛŒØ§ Box Ú©Ù†Ù‡ ÛŒØ§ Ø¨Ù‡ Ø¹Ø¨Ø§Ø±ØªÛŒ Ø¯ÛŒÚ¯Ø± Ø³Ø¹ÛŒ Ø¯Ø§Ø±Ù‡ Ø¯ÙˆØªØ§ Ø¹Ø¨Ø§Ø±Øª Ø±Ùˆ Ø¨Ù‡ ÛŒÙ‡ ØªØ§ÛŒÙ¾ ØªØ¨Ø¯ÛŒÙ„ Ú©Ù†Ù‡

### Ø§ÛŒÙˆÙ†Øª Ù„ÙˆÙ¾ Ú†ÛŒÙ‡ØŸ

Ø§ÛŒÙˆÙ†Øª Ù„ÙˆÙ¾ ÛŒÙ‡ Ù…Ú©Ø§Ù†ÛŒØ³Ù…ÛŒÙ‡ ØªÙˆ Ù…Ø­ÛŒØ· Ø§Ø¬Ø±Ø§ÛŒ Ø¬Ø§ÙˆØ§Ø§Ø³Ú©Ø±ÛŒÙ¾Øª (Ù…Ø«Ù„ Ù…Ø±ÙˆØ±Ú¯Ø± ÛŒØ§ Node.js) Ú©Ù‡ Ú©Ø§Ø±Ø´ Ù…Ø¯ÛŒØ±ÛŒØª Ø¹Ù…Ù„ÛŒØ§Øªâ€ŒÙ‡Ø§ÛŒ Ù‡Ù…Ø²Ù…Ø§Ù† (Synchronous) Ùˆ Ù†Ø§Ù‡Ù…Ø²Ù…Ø§Ù† (Asynchronous) Ù‡Ø³Øª. Ø§ÛŒÙ†Ø·ÙˆØ±ÛŒ Ú©Ø§Ø± Ù…ÛŒÚ©Ù†Ù‡:

1. **Ø¹Ù…Ù„ÛŒØ§Øªâ€ŒÙ‡Ø§ÛŒ Ù‡Ù…Ø²Ù…Ø§Ù†**: ÙˆÙ‚ØªÛŒ Ú©Ø¯ Ø¬Ø§ÙˆØ§Ø§Ø³Ú©Ø±ÛŒÙ¾Øª Ø§Ø¬Ø±Ø§ Ù…ÛŒØ´Ù‡ØŒ Ø¹Ù…Ù„ÛŒØ§Øªâ€ŒÙ‡Ø§ÛŒ Ø¹Ø§Ø¯ÛŒ (Ù…Ø«Ù„ Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ø³Ø§Ø¯Ù‡) Ù…Ø³ØªÙ‚ÛŒÙ… ØªÙˆÂ **Ú©Ø§Ù„ Ø§Ø³ØªÚ©**Â (Call Stack) Ø§Ø¬Ø±Ø§ Ù…ÛŒØ´Ù†.
    
2. **Ø¹Ù…Ù„ÛŒØ§Øªâ€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù‡Ù…Ø²Ù…Ø§Ù†**: Ø§Ú¯Ø± Ø¨Ù‡ ÛŒÙ‡ Ø¹Ù…Ù„ÛŒØ§Øª Ù†Ø§Ù‡Ù…Ø²Ù…Ø§Ù† Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú©Ù†ÛŒÙ… (Ù…Ø«Ù„Â `setTimeout`Â ÛŒØ§ ÛŒÙ‡ Ø¯Ø±Ø®ÙˆØ§Ø³Øª HTTP)ØŒ Ø§ÛŒÙ† Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ù‡Â **Web API**Â (ØªÙˆ Ù…Ø±ÙˆØ±Ú¯Ø±) ÛŒØ§Â **Node.js API**Â (ØªÙˆ Ø³Ø±ÙˆØ±) Ø³Ù¾Ø±Ø¯Ù‡ Ù…ÛŒØ´Ù‡ ØªØ§ ØªÙˆ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø§Ù†Ø¬Ø§Ù… Ø¨Ø´Ù‡.
    
3. **ØµÙØ­Ø§Øª Ø§Ù†ØªØ¸Ø§Ø±**: ÙˆÙ‚ØªÛŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù†Ø§Ù‡Ù…Ø²Ù…Ø§Ù† ØªÙ…ÙˆÙ… Ø´Ø¯ØŒ ØªØ§Ø¨Ø¹ Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ Ø§ÙˆÙ† (Ù…Ø«Ù„Ø§Ù‹ ÛŒÙ‡ ØªØ§Ø¨Ø¹ callback) ØªÙˆ ÛŒÙ‡ ØµÙ Ù‚Ø±Ø§Ø± Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ù‡. Ø¯Ùˆ Ù†ÙˆØ¹ ØµÙ Ø¯Ø§Ø±ÛŒÙ…:
    
    - **ØµÙ Ù…ÛŒÚ©Ø±ÙˆØªØ³Ú©â€ŒÙ‡Ø§ (Microtask Queue)**: Ø§ÛŒÙ† ØµÙ Ø¨Ø±Ø§ÛŒ Ú†ÛŒØ²Ø§ÛŒÛŒ Ù…Ø«Ù„ PromiseÙ‡Ø§ (`then`,Â `catch`,Â `finally`) ÙˆÂ `queueMicrotask`Â Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒØ´Ù‡.
        
    - **ØµÙ Ù…Ø§Ú©Ø±ÙˆØªØ³Ú©â€ŒÙ‡Ø§ (Macrotask Queue)**: Ø§ÛŒÙ† ØµÙ Ø¨Ø±Ø§ÛŒ Ú†ÛŒØ²Ø§ÛŒÛŒ Ù…Ø«Ù„Â `setTimeout`ØŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§ÛŒ HTTP Ùˆ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ UI (Ù…Ø«Ù„ Ú©Ù„ÛŒÚ© ÛŒØ§ Ø§Ø³Ú©Ø±ÙˆÙ„) Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒØ´Ù‡.
        
4. **Ù†Ù‚Ø´ Ø§ÛŒÙˆÙ†Øª Ù„ÙˆÙ¾**: Ø§ÛŒÙˆÙ†Øª Ù„ÙˆÙ¾ Ù…Ø¯Ø§Ù… Ú†Ú© Ù…ÛŒâ€ŒÚ©Ù†Ù‡ Ú©Ù‡ Ø¢ÛŒØ§ Ú©Ø§Ù„ Ø§Ø³ØªÚ© Ø®Ø§Ù„ÛŒÙ‡ ÛŒØ§ Ù†Ù‡. Ø§Ú¯Ø± Ø®Ø§Ù„ÛŒ Ø¨ÙˆØ¯ØŒ Ø§ÙˆÙ„ Ø³Ø±Ø§ØºÂ **ØµÙ Ù…ÛŒÚ©Ø±ÙˆØªØ³Ú©â€ŒÙ‡Ø§**Â Ù…ÛŒâ€ŒØ±Ù‡ Ùˆ Ù‡Ù…Ù‡â€ŒÛŒ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø§ÙˆÙ† ØµÙ Ø±Ùˆ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒØ¯Ù‡. Ø¨Ø¹Ø¯Ø´ Ø³Ø±Ø§ØºÂ **ØµÙ Ù…Ø§Ú©Ø±ÙˆØªØ³Ú©â€ŒÙ‡Ø§**Â Ù…ÛŒâ€ŒØ±Ù‡ Ùˆ ÙÙ‚Ø· ÛŒÙ‡ Ú©Ø§Ø± Ø§Ø² Ø§ÙˆÙ† ØµÙ Ø±Ùˆ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒØ¯Ù‡. Ø§Ù…Ø§ Ø¨Ø¹Ø¯ Ø§Ø² Ù‡Ø± Ù…Ø§Ú©Ø±ÙˆØªØ³Ú©ØŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ú†Ú© Ù…ÛŒâ€ŒÚ©Ù†Ù‡ Ú©Ù‡ Ø¢ÛŒØ§ Ù…ÛŒÚ©Ø±ÙˆØªØ³Ú© Ø¬Ø¯ÛŒØ¯ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡ ÛŒØ§ Ù†Ù‡. Ø§ÛŒÙ† Ø±ÙˆÙ†Ø¯ Ù…Ø¯Ø§Ù… ØªÚ©Ø±Ø§Ø± Ù…ÛŒØ´Ù‡.

### Ø§ event delegation Ú†ÛŒÙ‡ØŸ


Ø§Event Delegation ÛŒÙ‡ ØªÚ©Ù†ÛŒÚ© ØªÙˆ Ø¬Ø§ÙˆØ§Ø§Ø³Ú©Ø±ÛŒÙ¾ØªÙ‡ Ú©Ù‡ Ø¨Ù‡ Ø¬Ø§ÛŒ Ø§ÛŒÙ†â€ŒÚ©Ù‡ Ø¨Ù‡ ØªÚ©â€ŒØªÚ© Ø¹Ù†Ø§ØµØ± (Ù…Ø«Ù„Ø§Ù‹ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ ÛŒØ§ Ù„ÛŒØ³Øªâ€ŒÙ‡Ø§) ÛŒÙ‡ Event Listener ÙˆØµÙ„ Ú©Ù†ÛŒÙ…ØŒ ÙÙ‚Ø· Ø¨Ù‡Â **Ù¾Ø¯Ø±Ø´ÙˆÙ†**Â (Parent Element) ÛŒÙ‡ Event Listener ÙˆØµÙ„ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…. ÙˆÙ‚ØªÛŒ ÛŒÙ‡ Ø§ÛŒÙˆÙ†Øª (Ù…Ø«Ù„ Ú©Ù„ÛŒÚ©) Ø±ÙˆÛŒ ÛŒÙ‡ Ø¹Ù†ØµØ± Ø§ØªÙØ§Ù‚ Ù…ÛŒâ€ŒØ§ÙØªÙ‡ØŒ Ø§ÛŒÙ† Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¨Ù‡ Ø³Ù…Øª Ø¨Ø§Ù„Ø§ ØªÙˆ DOM Ø­Ø±Ú©Øª Ù…ÛŒâ€ŒÚ©Ù†Ù‡ (Ø¨Ù‡ Ø§ÛŒÙ† Ù…ÛŒâ€ŒÚ¯Ù†Â **Event Bubbling**) Ùˆ Ø¨Ù‡ Ù¾Ø¯Ø±Ø´ Ù…ÛŒâ€ŒØ±Ø³Ù‡. Ø§ÙˆÙ†Ø¬Ø§ØŒ Ù¾Ø¯Ø± Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ ØªØ´Ø®ÛŒØµ Ø¨Ø¯Ù‡ Ú©Ù‡ Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø±ÙˆÛŒ Ú©Ø¯ÙˆÙ… Ø¹Ù†ØµØ± Ø§ØªÙØ§Ù‚ Ø§ÙØªØ§Ø¯Ù‡ Ùˆ Ø¨Ø±Ø§Ø³Ø§Ø³ Ø§ÙˆÙ† Ø¹Ù…Ù„ Ú©Ù†Ù‡.

---

### Ú†Ø±Ø§ Event Delegation Ù…ÙÛŒØ¯Ù‡ØŸ

1. **Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØªØ± Ùˆ Ø³Ø±ÛŒØ¹â€ŒØªØ±**: Ø¨Ù‡ Ø¬Ø§ÛŒ Ø§ÛŒÙ†â€ŒÚ©Ù‡ Ø¨Ù‡ ØµØ¯Ù‡Ø§ Ø¹Ù†ØµØ± Event Listener ÙˆØµÙ„ Ú©Ù†ÛŒÙ…ØŒ ÙÙ‚Ø· ÛŒÙ‡ Ø¯ÙˆÙ†Ù‡ ÙˆØµÙ„ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…. Ø§ÛŒÙ† Ú©Ø§Ø± Ø­Ø§ÙØ¸Ù‡ Ú©Ù…ØªØ±ÛŒ Ù…ØµØ±Ù Ù…ÛŒâ€ŒÚ©Ù†Ù‡ Ùˆ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø±Ùˆ Ø¨Ù‡ØªØ± Ù…ÛŒâ€ŒÚ©Ù†Ù‡ØŒ Ù…Ø®ØµÙˆØµØ§Ù‹ Ø¨Ø±Ø§ÛŒ Ù„ÛŒØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯ ÛŒØ§ Ø¹Ù†Ø§ØµØ±ÛŒ Ú©Ù‡ Ù…Ø¯Ø§Ù… ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒÚ©Ù†Ù†.
    
2. **Ú©Ø¯ ØªÙ…ÛŒØ²â€ŒØªØ± Ùˆ Ø³Ø§Ø¯Ù‡â€ŒØªØ±**: ÙÙ‚Ø· ÛŒÙ‡ Ø¨Ø§Ø± Ú©Ø¯ Ø±Ùˆ Ù…ÛŒâ€ŒÙ†ÙˆÛŒØ³ÛŒ Ùˆ Ù‡Ù…Ù‡ Ú†ÛŒØ² Ø±Ùˆ ØªÙˆ Ù‡Ù…ÙˆÙ† Ù¾Ø¯Ø± Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÛŒâ€ŒÚ©Ù†ÛŒ. Ø§ÛŒÙ†Ø·ÙˆØ±ÛŒ Ú©Ø¯Øª Ù…Ø±ØªØ¨â€ŒØªØ± Ùˆ Ù‚Ø§Ø¨Ù„ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒâ€ŒØªØ± Ù…ÛŒØ´Ù‡.
    
3. **Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² Ø¹Ù†Ø§ØµØ± Ø¯Ø§ÛŒÙ†Ø§Ù…ÛŒÚ©**: Ø§Ú¯Ù‡ Ø¹Ù†Ø§ØµØ± Ø¬Ø¯ÛŒØ¯ÛŒ Ø¨Ù‡ ØµÙØ­Ù‡ Ø§Ø¶Ø§ÙÙ‡ Ø¨Ø´Ù† ÛŒØ§ Ø­Ø°Ù Ø¨Ø´Ù†ØŒ Ù†ÛŒØ§Ø²ÛŒ Ù†ÛŒØ³Øª Ø¯Ø³ØªÛŒ Event Listener Ø¨Ù‡Ø´ÙˆÙ† ÙˆØµÙ„ ÛŒØ§ Ø§Ø²Ø´ÙˆÙ† Ø­Ø°Ù Ú©Ù†ÛŒ. Ú†ÙˆÙ† Ù¾Ø¯Ø±Ø´ÙˆÙ† Ø¯Ø§Ø±Ù‡ Ù‡Ù…Ù‡â€ŒÚ†ÛŒ Ø±Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÛŒâ€ŒÚ©Ù†Ù‡.
    

    

---

### Ù…Ø«Ø§Ù„:

ÙØ±Ø¶ Ú©Ù† ÛŒÙ‡ Ù„ÛŒØ³Øª Ø¯Ø§ÛŒÙ†Ø§Ù…ÛŒÚ© Ø¯Ø§Ø±ÛŒ Ùˆ Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ ÙˆÙ‚ØªÛŒ Ø±ÙˆÛŒ Ù‡Ø± Ø¢ÛŒØªÙ… Ú©Ù„ÛŒÚ© Ù…ÛŒâ€ŒØ´Ù‡ØŒ ÛŒÙ‡ Ú©Ø§Ø±ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø¨Ø´Ù‡:

~~~html
<ul id="parent-list">
  <li>Ø¢ÛŒØªÙ… Û±</li>
  <li>Ø¢ÛŒØªÙ… Û²</li>
  <li>Ø¢ÛŒØªÙ… Û³</li>
</ul>
~~~

Ø¨Ù‡ Ø¬Ø§ÛŒ Ø§ÛŒÙ†â€ŒÚ©Ù‡ Ø¨Ù‡ Ù‡Ø±Â `<li>`Â ÛŒÙ‡ Event Listener ÙˆØµÙ„ Ú©Ù†ÛŒØŒ ÙÙ‚Ø· Ø¨Ù‡Â `<ul>`Â ÛŒÙ‡ Ø¯ÙˆÙ†Ù‡ ÙˆØµÙ„ Ù…ÛŒâ€ŒÚ©Ù†ÛŒ:
~~~javascript

document.getElementById('parent-list').addEventListener('click', function(event) {
  if (event.target.tagName === 'LI') {
    console.log('Ú©Ù„ÛŒÚ© Ø±ÙˆÛŒ:', event.target.textContent);
  }
});
~~~


### Ø§ event bubbling Ú†ÛŒÙ‡ØŸ

### Ø§ event capturing Ú†ÛŒÙ‡ØŸ



### What is the difference between aÂ `Map`Â object and a plain object in JavaScript?

[](https://github.com/yangshun/top-javascript-interview-questions?tab=readme-ov-file#what-is-the-difference-between-a-map-object-and-a-plain-object-in-javascript)

BothÂ `Map`Â objects and plain objects in JavaScript can store key-value pairs, but they have several key differences:

| Feature       | `Map`                                                                 | Plain object                                    |
| ------------- | --------------------------------------------------------------------- | ----------------------------------------------- |
| Key type      | Any data type                                                         | String (or Symbol)                              |
| Key order     | Maintained                                                            | Not guaranteed                                  |
| Size property | Yes (`size`)                                                          | None                                            |
| Iteration     | `forEach`,Â `keys()`,Â `values()`,Â `entries()`                          | `for...in`,Â `Object.keys()`, etc.               |
| Inheritance   | No                                                                    | Yes                                             |
| Performance   | Generally better for larger datasets and frequent additions/deletions | Faster for small datasets and simple operations |
| Serializable  | No                                                                    | Yes                                             |


### Map/weakmap set/weakset
|Feature|Map|WeakMap|Set|WeakSet|
|---|---|---|---|---|
|Key Types|Any data type|Objects (weak references)|Any data type (unique)|Objects (weak references, unique)|
|Garbage Collection|Keys and values are not garbage collected|Keys can be garbage collected if not referenced elsewhere|Elements are not garbage collected|Elements can be garbage collected if not referenced elsewhere|
|Use Cases|General-purpose key-value storage|Caching, private DOM node data|Removing duplicates, membership checks|Object weak references, custom use cases|
### What are server-sent events?

[Server-sent events (SSE)](https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface)Â is a standard that allows a web page to receive automatic updates from a server via an HTTP connection. Server-sent events are used withÂ `EventSource`Â instances that opens a connection with a server and allows client to receive events from the server. Connections created by server-sent events are persistent (similar to theÂ `WebSocket`s), however there are a few differences:

|Property|`WebSocket`|`EventSource`|
|---|---|---|
|Direction|Bi-directional â€“ both client and server can exchange messages|Unidirectional â€“ only server sends data|
|Data type|Binary and text data|Only text|
|Protocol|WebSocket protocol (`ws://`)|Regular HTTP (`http://`)|


### What are JavaScript object property flags and descriptors?

In JavaScript, property flags and descriptors manage the behavior and attributes of object properties.

**Property flags**

Property flags are used to specify the behavior of a property on an object. Here are the available flags:

- `writable`: Specifies whether the property can be written to. Defaults toÂ `true`.
- `enumerable`: Specifies whether the property is enumerable. Defaults toÂ `true`.
- `configurable`: Specifies whether the property can be deleted or its attributes changed. Default isÂ `true`.
### How does JavaScript garbage collection work?
[[Notes/Software/Javascript/Garbage Collection|Garbage Collection]]

### What is the purpose of theÂ `new`Â keyword?

TheÂ `new`Â keyword in JavaScript is used to create an instance of a user-defined object type or one of the built-in object types that has a constructor function. When you useÂ `new`, it does four things: it creates a new object, sets the prototype, bindsÂ `this`Â to the new object, and returns the new object.

```js
function Person(name) {
  this.name = name;
}

const person1 = new Person('Alice');
console.log(person1.name); // Alice
```

### Explain the concept of debouncing and throttling

[](https://github.com/yangshun/top-javascript-interview-questions?tab=readme-ov-file#explain-the-concept-of-debouncing-and-throttling)

Debouncing and throttling are techniques used to control the rate at which a function is executed. Debouncing ensures that a function is only called after a specified delay has passed since the last time it was invoked. Throttling ensures that a function is called at most once in a specified time interval.

Debouncing delays the execution of a function until a certain amount of time has passed since it was last called. This is useful for scenarios like search input fields where you want to wait until the user has stopped typing before making an API call.

```js
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}
```

Throttling ensures that a function is called at most once in a specified time interval. This is useful for scenarios like window resizing or scrolling where you want to limit the number of times a function is called.

```js
function throttle(func, limit) {
  let inThrottle;
  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}
```

### What are some techniques for reducing reflows and repaints?


To reduce reflows and repaints, you can minimize DOM manipulations, batch DOM changes, use CSS classes for style changes, avoid complex CSS selectors, and useÂ `requestAnimationFrame`Â for animations. Additionally, consider usingÂ `will-change`Â for elements that will change frequently and avoid layout thrashing by reading and writing to the DOM separately.


### What are Web Workers and how can they be used to improve performance?

Web Workers are a way to run JavaScript in the background, separate from the main execution thread of a web application. This helps in performing heavy computations without blocking the user interface. You can create a Web Worker using theÂ `Worker`Â constructor and communicate with it using theÂ `postMessage`Â andÂ `onmessage`Â methods.

```js
// main.js
const worker = new Worker('worker.js');
worker.postMessage('Hello, worker!');

worker.onmessage = function (event) {
  console.log('Message from worker:', event.data);
};

// worker.js
onmessage = function (event) {
  console.log('Message from main script:', event.data);
  postMessage('Hello, main script!');
};
```

### What is the Factory pattern and how is it used?

[](https://github.com/yangshun/top-javascript-interview-questions?tab=readme-ov-file#what-is-the-factory-pattern-and-how-is-it-used)

The Factory pattern is a design pattern used to create objects without specifying the exact class of the object that will be created. It provides a way to encapsulate the instantiation logic and can be particularly useful when the creation process is complex or when the type of object to be created is determined at runtime.

For example, in JavaScript, you can use a factory function to create different types of objects:

```js
function createAnimal(type) {
  if (type === 'dog') {
    return { sound: 'woof' };
  } else if (type === 'cat') {
    return { sound: 'meow' };
  }
}

const dog = createAnimal('dog');
const cat = createAnimal('cat');
```

### Ø®Ø·Ø§ÛŒ chunk load error
Ø¨Ø±Ø§ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒÙ‡ Ú©Ù‡ ÙˆÙ‚ØªÛŒ ÛŒÙ‡ Ú©Ø§Ù…Ù¾ÙˆÙ†Ù†Øª ÛŒÙ‡ Ú©Ø§Ù…Ù¾Ù¾ÙˆÙ†Øª Ø¯ÛŒÚ¯Ù‡ Ú©Ù‡ Ù„ÙˆØ¯ Ù…ÛŒÚ©Ù†Ù‡ Ù†ÛŒØ³Øª Ù…Ø®ØµÙˆØµØ§ ØªÙˆÛŒ lazy loading Ù…ÛŒØªÙˆÙ†ÛŒÙ… Ø¨Ø§ susspene Ø¬Ù„ÙˆÛŒ ØªØ±Ú©ÛŒØ¯Ù† ØµÙØ­Ù‡ Ø±Ùˆ Ø¨Ú¯ÛŒØ±ÛŒÙ…

### Ø§ shadow dom Ú†ÛŒÙ‡

Ø§**Shadow DOM** ÛŒÙ‡ ØªÚ©Ù†ÙˆÙ„ÙˆÚ˜ÛŒ Ø¯Ø± Web PlatformÙ‡ Ú©Ù‡ Ø¨Ù‡Øª Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡ **ÛŒÙ‡ Ø¯Ø±Ø®Øª DOM Ø§ÛŒØ²ÙˆÙ„Ù‡** Ø¯Ø§Ø®Ù„ ÛŒÙ‡ Ø§Ù„Ù…Ù†Øª Ø¨Ø³Ø§Ø²ÛŒ.  
ÛŒØ¹Ù†ÛŒ ÛŒÙ‡ Ø¬ÙˆØ± Â«Ù…ÛŒÙ†ÛŒ DOMÂ» Ø¯Ø§Ø®Ù„ ÛŒÙ‡ Ø§Ù„Ù…Ù†Øª Ú©Ù‡ Ø¨Ù‚ÛŒÙ‡â€ŒÛŒ ØµÙØ­Ù‡ Ù†Ù…ÛŒâ€ŒØªÙˆÙ†Ù† Ø±Ø§Ø­Øª Ø¨Ù‡Ø´ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù† ÛŒØ§ Ø±ÙˆØ´ ØªØ§Ø«ÛŒØ± Ø¨Ø°Ø§Ø±Ù† (Ù…Ú¯Ø± Ø¨Ø§ Ø§Ø¬Ø§Ø²Ù‡â€ŒÛŒ ØªÙˆ).

---

### ğŸ“¦ Ú†Ù‡ Ù…Ø´Ú©Ù„ÛŒ Ø±Ùˆ Ø­Ù„ Ù…ÛŒâ€ŒÚ©Ù†Ù‡ØŸ

ÙØ±Ø¶ Ú©Ù† ÛŒÙ‡ Ú©Ø§Ù…Ù¾ÙˆÙ†Ù†Øª `my-button` Ø³Ø§Ø®ØªÛŒ Ú©Ù‡ ÛŒÙ‡ `button` Ø¨Ø§ Ø§Ø³ØªØ§ÛŒÙ„ Ø®Ø§ØµÙ‡. Ø­Ø§Ù„Ø§ ØªÙˆÛŒ ØµÙØ­Ù‡ ÛŒÚ©ÛŒ Ø¯ÛŒÚ¯Ù‡ Ù‡Ù… ÛŒÙ‡ Ø§Ø³ØªØ§ÛŒÙ„ global ØªØ¹Ø±ÛŒÙ Ú©Ø±Ø¯Ù‡:

`button {   background: red; }`

Ø¨Ø¯ÙˆÙ† shadow DOMØŒ Ø§ÙˆÙ† Ø§Ø³ØªØ§ÛŒÙ„ Ù‚Ø±Ù…Ø² Ú©Ù„ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ ØªÙˆÛŒ ØµÙØ­Ù‡ Ø±Ùˆ ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒØ¯Ù‡â€”even ØªÙˆÛŒ Ú©Ø§Ù…Ù¾ÙˆÙ†Ù†ØªØª!

ÙˆÙ„ÛŒ Ø¨Ø§ shadow DOM:

- Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ Ùˆ DOM Ø¯Ø§Ø®Ù„ÛŒ **Ø§ÛŒØ²ÙˆÙ„Ù‡** Ù…ÛŒâ€ŒØ´Ù†
    
- Ø§Ø² Ø¨ÛŒØ±ÙˆÙ† Ù†Ù…ÛŒâ€ŒØªÙˆÙ†Ù† ØªØºÛŒÛŒØ±Ø´ Ø¨Ø¯Ù†
    
- ØªÙˆ Ù‡Ù… Ù†Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ Ø§ØªÙØ§Ù‚ÛŒ Ú†ÛŒØ²ÛŒ Ø§Ø² Ø¨ÛŒØ±ÙˆÙ† Ø®Ø±Ø§Ø¨ Ú©Ù†ÛŒ

~~~js
const shadow = this.attachShadow({ mode: 'open' });      shadow.innerHTML = `       <style>         button {           background: blue;           color: white;           border: none;           padding: 10px;           border-radius: 8px;         }       </style>       <button>Click me</button>     `;   } } customElements.define('my-button', MyButton);



~~~


### Ú†Ø¬ÙˆØ±ÛŒ Ø§Ø³ØªÛŒØª Ø±Ùˆ Ø¨Ù‡ ØµÙˆØ±Øª Ø³ÛŒÙ†Ú© Ø§Ù¾Ø¯ÛŒØª Ú©Ù†ÛŒÙ…ØŸ


Ø§React ØªÙˆÛŒ Ù†Ø³Ø®Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ (Ø§Ø² 18 Ø¨Ù‡ Ø¨Ø¹Ø¯) Ø¢Ù¾Ø¯ÛŒØªâ€ŒÙ‡Ø§ Ø±Ùˆ **batch** Ù…ÛŒâ€ŒÚ©Ù†Ù‡ (ÛŒØ¹Ù†ÛŒ Ú†Ù†Ø¯ Ø¢Ù¾Ø¯ÛŒØª Ø±Ùˆ Ø¨Ø§ Ù‡Ù… Ø¬Ù…Ø¹ Ù…ÛŒâ€ŒÚ©Ù†Ù‡) ØªØ§ performance Ø¨Ù‡ØªØ± Ø¨Ø´Ù‡.  
Ø§Ù…Ø§ Ú¯Ø§Ù‡ÛŒ ÙˆÙ‚ØªØ§ Ù„Ø§Ø²Ù…Ù‡ ÛŒÙ‡ Ø¢Ù¾Ø¯ÛŒØª ÙÙˆØ±Ø§Ù‹ Ø§Ø¬Ø±Ø§ Ø¨Ø´Ù‡ØŒ Ù…Ø«Ù„Ø§Ù‹:

- Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ Ø¨Ù„Ø§ÙØ§ØµÙ„Ù‡ Ø¨Ø¹Ø¯ Ø§Ø² ÛŒÙ‡ ØªØºÛŒÛŒØ± Ø¯Ø± DOM Ø§Ù†Ø¯Ø§Ø²Ù‡ Ø¨Ú¯ÛŒØ±ÛŒ
    
- Ø§Ù†ÛŒÙ…ÛŒØ´Ù† ÛŒØ§ ØªØ±Ù†Ø²ÛŒØ´Ù† Ø®Ø§ØµÛŒ Ø¯Ø§Ø±ÛŒ
    
- ÛŒÙ‡ ÙˆØ±ÙˆØ¯ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø³Ø±ÛŒØ¹ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¬ÙˆØ§Ø¨ Ø¯Ø§Ø±Ù‡
    
- Ø¨Ø§ÛŒØ¯ Ù‚Ø¨Ù„ Ø§Ø² Ú©Ø§Ø±ÛŒ Ú©Ù‡ React Ù‡Ù†ÙˆØ² Ù†Ø±ÙØªÙ‡ Ø³Ù…ØªØ´ØŒ ÛŒÙ‡ Ú†ÛŒØ² Ø±Ùˆ ØªÙˆÛŒ DOM Ø¨Ø¨ÛŒÙ†ÛŒ ÛŒØ§ log Ú©Ù†ÛŒ


~~~js
import { flushSync } from 'react-dom';  
flushSync(() => {   setState(newValue); // ÙÙˆØ±Ø§Ù‹ Ø§ÛŒÙ†Ùˆ Ø±Ù†Ø¯Ø± Ú©Ù† });
~~~

